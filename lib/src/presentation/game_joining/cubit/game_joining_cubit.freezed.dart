// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'game_joining_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$GameJoiningState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() searchingForExistingGame,
    required TResult Function() connectingToExistingGame,
    required TResult Function(String serverIp) connectedToExistingGame,
    required TResult Function() startingServer,
    required TResult Function(int numberOfPlayers) waitingForPlayers,
    required TResult Function(int numberOfPlayers) startOfGame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? searchingForExistingGame,
    TResult? Function()? connectingToExistingGame,
    TResult? Function(String serverIp)? connectedToExistingGame,
    TResult? Function()? startingServer,
    TResult? Function(int numberOfPlayers)? waitingForPlayers,
    TResult? Function(int numberOfPlayers)? startOfGame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? searchingForExistingGame,
    TResult Function()? connectingToExistingGame,
    TResult Function(String serverIp)? connectedToExistingGame,
    TResult Function()? startingServer,
    TResult Function(int numberOfPlayers)? waitingForPlayers,
    TResult Function(int numberOfPlayers)? startOfGame,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SearchingForExistingGame value)
        searchingForExistingGame,
    required TResult Function(_ConnectingToExistingGame value)
        connectingToExistingGame,
    required TResult Function(_ConnectedToExistingGame value)
        connectedToExistingGame,
    required TResult Function(_StartingServer value) startingServer,
    required TResult Function(_WaitingForPlayers value) waitingForPlayers,
    required TResult Function(_StartOfGame value) startOfGame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SearchingForExistingGame value)?
        searchingForExistingGame,
    TResult? Function(_ConnectingToExistingGame value)?
        connectingToExistingGame,
    TResult? Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult? Function(_StartingServer value)? startingServer,
    TResult? Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult? Function(_StartOfGame value)? startOfGame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SearchingForExistingGame value)? searchingForExistingGame,
    TResult Function(_ConnectingToExistingGame value)? connectingToExistingGame,
    TResult Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult Function(_StartingServer value)? startingServer,
    TResult Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult Function(_StartOfGame value)? startOfGame,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GameJoiningStateCopyWith<$Res> {
  factory $GameJoiningStateCopyWith(
          GameJoiningState value, $Res Function(GameJoiningState) then) =
      _$GameJoiningStateCopyWithImpl<$Res, GameJoiningState>;
}

/// @nodoc
class _$GameJoiningStateCopyWithImpl<$Res, $Val extends GameJoiningState>
    implements $GameJoiningStateCopyWith<$Res> {
  _$GameJoiningStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialCopyWith<$Res> {
  factory _$$_InitialCopyWith(
          _$_Initial value, $Res Function(_$_Initial) then) =
      __$$_InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialCopyWithImpl<$Res>
    extends _$GameJoiningStateCopyWithImpl<$Res, _$_Initial>
    implements _$$_InitialCopyWith<$Res> {
  __$$_InitialCopyWithImpl(_$_Initial _value, $Res Function(_$_Initial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'GameJoiningState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() searchingForExistingGame,
    required TResult Function() connectingToExistingGame,
    required TResult Function(String serverIp) connectedToExistingGame,
    required TResult Function() startingServer,
    required TResult Function(int numberOfPlayers) waitingForPlayers,
    required TResult Function(int numberOfPlayers) startOfGame,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? searchingForExistingGame,
    TResult? Function()? connectingToExistingGame,
    TResult? Function(String serverIp)? connectedToExistingGame,
    TResult? Function()? startingServer,
    TResult? Function(int numberOfPlayers)? waitingForPlayers,
    TResult? Function(int numberOfPlayers)? startOfGame,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? searchingForExistingGame,
    TResult Function()? connectingToExistingGame,
    TResult Function(String serverIp)? connectedToExistingGame,
    TResult Function()? startingServer,
    TResult Function(int numberOfPlayers)? waitingForPlayers,
    TResult Function(int numberOfPlayers)? startOfGame,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SearchingForExistingGame value)
        searchingForExistingGame,
    required TResult Function(_ConnectingToExistingGame value)
        connectingToExistingGame,
    required TResult Function(_ConnectedToExistingGame value)
        connectedToExistingGame,
    required TResult Function(_StartingServer value) startingServer,
    required TResult Function(_WaitingForPlayers value) waitingForPlayers,
    required TResult Function(_StartOfGame value) startOfGame,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SearchingForExistingGame value)?
        searchingForExistingGame,
    TResult? Function(_ConnectingToExistingGame value)?
        connectingToExistingGame,
    TResult? Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult? Function(_StartingServer value)? startingServer,
    TResult? Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult? Function(_StartOfGame value)? startOfGame,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SearchingForExistingGame value)? searchingForExistingGame,
    TResult Function(_ConnectingToExistingGame value)? connectingToExistingGame,
    TResult Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult Function(_StartingServer value)? startingServer,
    TResult Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult Function(_StartOfGame value)? startOfGame,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements GameJoiningState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$$_SearchingForExistingGameCopyWith<$Res> {
  factory _$$_SearchingForExistingGameCopyWith(
          _$_SearchingForExistingGame value,
          $Res Function(_$_SearchingForExistingGame) then) =
      __$$_SearchingForExistingGameCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SearchingForExistingGameCopyWithImpl<$Res>
    extends _$GameJoiningStateCopyWithImpl<$Res, _$_SearchingForExistingGame>
    implements _$$_SearchingForExistingGameCopyWith<$Res> {
  __$$_SearchingForExistingGameCopyWithImpl(_$_SearchingForExistingGame _value,
      $Res Function(_$_SearchingForExistingGame) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SearchingForExistingGame implements _SearchingForExistingGame {
  const _$_SearchingForExistingGame();

  @override
  String toString() {
    return 'GameJoiningState.searchingForExistingGame()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SearchingForExistingGame);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() searchingForExistingGame,
    required TResult Function() connectingToExistingGame,
    required TResult Function(String serverIp) connectedToExistingGame,
    required TResult Function() startingServer,
    required TResult Function(int numberOfPlayers) waitingForPlayers,
    required TResult Function(int numberOfPlayers) startOfGame,
  }) {
    return searchingForExistingGame();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? searchingForExistingGame,
    TResult? Function()? connectingToExistingGame,
    TResult? Function(String serverIp)? connectedToExistingGame,
    TResult? Function()? startingServer,
    TResult? Function(int numberOfPlayers)? waitingForPlayers,
    TResult? Function(int numberOfPlayers)? startOfGame,
  }) {
    return searchingForExistingGame?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? searchingForExistingGame,
    TResult Function()? connectingToExistingGame,
    TResult Function(String serverIp)? connectedToExistingGame,
    TResult Function()? startingServer,
    TResult Function(int numberOfPlayers)? waitingForPlayers,
    TResult Function(int numberOfPlayers)? startOfGame,
    required TResult orElse(),
  }) {
    if (searchingForExistingGame != null) {
      return searchingForExistingGame();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SearchingForExistingGame value)
        searchingForExistingGame,
    required TResult Function(_ConnectingToExistingGame value)
        connectingToExistingGame,
    required TResult Function(_ConnectedToExistingGame value)
        connectedToExistingGame,
    required TResult Function(_StartingServer value) startingServer,
    required TResult Function(_WaitingForPlayers value) waitingForPlayers,
    required TResult Function(_StartOfGame value) startOfGame,
  }) {
    return searchingForExistingGame(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SearchingForExistingGame value)?
        searchingForExistingGame,
    TResult? Function(_ConnectingToExistingGame value)?
        connectingToExistingGame,
    TResult? Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult? Function(_StartingServer value)? startingServer,
    TResult? Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult? Function(_StartOfGame value)? startOfGame,
  }) {
    return searchingForExistingGame?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SearchingForExistingGame value)? searchingForExistingGame,
    TResult Function(_ConnectingToExistingGame value)? connectingToExistingGame,
    TResult Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult Function(_StartingServer value)? startingServer,
    TResult Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult Function(_StartOfGame value)? startOfGame,
    required TResult orElse(),
  }) {
    if (searchingForExistingGame != null) {
      return searchingForExistingGame(this);
    }
    return orElse();
  }
}

abstract class _SearchingForExistingGame implements GameJoiningState {
  const factory _SearchingForExistingGame() = _$_SearchingForExistingGame;
}

/// @nodoc
abstract class _$$_ConnectingToExistingGameCopyWith<$Res> {
  factory _$$_ConnectingToExistingGameCopyWith(
          _$_ConnectingToExistingGame value,
          $Res Function(_$_ConnectingToExistingGame) then) =
      __$$_ConnectingToExistingGameCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ConnectingToExistingGameCopyWithImpl<$Res>
    extends _$GameJoiningStateCopyWithImpl<$Res, _$_ConnectingToExistingGame>
    implements _$$_ConnectingToExistingGameCopyWith<$Res> {
  __$$_ConnectingToExistingGameCopyWithImpl(_$_ConnectingToExistingGame _value,
      $Res Function(_$_ConnectingToExistingGame) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ConnectingToExistingGame implements _ConnectingToExistingGame {
  const _$_ConnectingToExistingGame();

  @override
  String toString() {
    return 'GameJoiningState.connectingToExistingGame()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConnectingToExistingGame);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() searchingForExistingGame,
    required TResult Function() connectingToExistingGame,
    required TResult Function(String serverIp) connectedToExistingGame,
    required TResult Function() startingServer,
    required TResult Function(int numberOfPlayers) waitingForPlayers,
    required TResult Function(int numberOfPlayers) startOfGame,
  }) {
    return connectingToExistingGame();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? searchingForExistingGame,
    TResult? Function()? connectingToExistingGame,
    TResult? Function(String serverIp)? connectedToExistingGame,
    TResult? Function()? startingServer,
    TResult? Function(int numberOfPlayers)? waitingForPlayers,
    TResult? Function(int numberOfPlayers)? startOfGame,
  }) {
    return connectingToExistingGame?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? searchingForExistingGame,
    TResult Function()? connectingToExistingGame,
    TResult Function(String serverIp)? connectedToExistingGame,
    TResult Function()? startingServer,
    TResult Function(int numberOfPlayers)? waitingForPlayers,
    TResult Function(int numberOfPlayers)? startOfGame,
    required TResult orElse(),
  }) {
    if (connectingToExistingGame != null) {
      return connectingToExistingGame();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SearchingForExistingGame value)
        searchingForExistingGame,
    required TResult Function(_ConnectingToExistingGame value)
        connectingToExistingGame,
    required TResult Function(_ConnectedToExistingGame value)
        connectedToExistingGame,
    required TResult Function(_StartingServer value) startingServer,
    required TResult Function(_WaitingForPlayers value) waitingForPlayers,
    required TResult Function(_StartOfGame value) startOfGame,
  }) {
    return connectingToExistingGame(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SearchingForExistingGame value)?
        searchingForExistingGame,
    TResult? Function(_ConnectingToExistingGame value)?
        connectingToExistingGame,
    TResult? Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult? Function(_StartingServer value)? startingServer,
    TResult? Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult? Function(_StartOfGame value)? startOfGame,
  }) {
    return connectingToExistingGame?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SearchingForExistingGame value)? searchingForExistingGame,
    TResult Function(_ConnectingToExistingGame value)? connectingToExistingGame,
    TResult Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult Function(_StartingServer value)? startingServer,
    TResult Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult Function(_StartOfGame value)? startOfGame,
    required TResult orElse(),
  }) {
    if (connectingToExistingGame != null) {
      return connectingToExistingGame(this);
    }
    return orElse();
  }
}

abstract class _ConnectingToExistingGame implements GameJoiningState {
  const factory _ConnectingToExistingGame() = _$_ConnectingToExistingGame;
}

/// @nodoc
abstract class _$$_ConnectedToExistingGameCopyWith<$Res> {
  factory _$$_ConnectedToExistingGameCopyWith(_$_ConnectedToExistingGame value,
          $Res Function(_$_ConnectedToExistingGame) then) =
      __$$_ConnectedToExistingGameCopyWithImpl<$Res>;
  @useResult
  $Res call({String serverIp});
}

/// @nodoc
class __$$_ConnectedToExistingGameCopyWithImpl<$Res>
    extends _$GameJoiningStateCopyWithImpl<$Res, _$_ConnectedToExistingGame>
    implements _$$_ConnectedToExistingGameCopyWith<$Res> {
  __$$_ConnectedToExistingGameCopyWithImpl(_$_ConnectedToExistingGame _value,
      $Res Function(_$_ConnectedToExistingGame) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? serverIp = null,
  }) {
    return _then(_$_ConnectedToExistingGame(
      null == serverIp
          ? _value.serverIp
          : serverIp // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ConnectedToExistingGame implements _ConnectedToExistingGame {
  _$_ConnectedToExistingGame(this.serverIp);

  @override
  final String serverIp;

  @override
  String toString() {
    return 'GameJoiningState.connectedToExistingGame(serverIp: $serverIp)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConnectedToExistingGame &&
            (identical(other.serverIp, serverIp) ||
                other.serverIp == serverIp));
  }

  @override
  int get hashCode => Object.hash(runtimeType, serverIp);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ConnectedToExistingGameCopyWith<_$_ConnectedToExistingGame>
      get copyWith =>
          __$$_ConnectedToExistingGameCopyWithImpl<_$_ConnectedToExistingGame>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() searchingForExistingGame,
    required TResult Function() connectingToExistingGame,
    required TResult Function(String serverIp) connectedToExistingGame,
    required TResult Function() startingServer,
    required TResult Function(int numberOfPlayers) waitingForPlayers,
    required TResult Function(int numberOfPlayers) startOfGame,
  }) {
    return connectedToExistingGame(serverIp);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? searchingForExistingGame,
    TResult? Function()? connectingToExistingGame,
    TResult? Function(String serverIp)? connectedToExistingGame,
    TResult? Function()? startingServer,
    TResult? Function(int numberOfPlayers)? waitingForPlayers,
    TResult? Function(int numberOfPlayers)? startOfGame,
  }) {
    return connectedToExistingGame?.call(serverIp);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? searchingForExistingGame,
    TResult Function()? connectingToExistingGame,
    TResult Function(String serverIp)? connectedToExistingGame,
    TResult Function()? startingServer,
    TResult Function(int numberOfPlayers)? waitingForPlayers,
    TResult Function(int numberOfPlayers)? startOfGame,
    required TResult orElse(),
  }) {
    if (connectedToExistingGame != null) {
      return connectedToExistingGame(serverIp);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SearchingForExistingGame value)
        searchingForExistingGame,
    required TResult Function(_ConnectingToExistingGame value)
        connectingToExistingGame,
    required TResult Function(_ConnectedToExistingGame value)
        connectedToExistingGame,
    required TResult Function(_StartingServer value) startingServer,
    required TResult Function(_WaitingForPlayers value) waitingForPlayers,
    required TResult Function(_StartOfGame value) startOfGame,
  }) {
    return connectedToExistingGame(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SearchingForExistingGame value)?
        searchingForExistingGame,
    TResult? Function(_ConnectingToExistingGame value)?
        connectingToExistingGame,
    TResult? Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult? Function(_StartingServer value)? startingServer,
    TResult? Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult? Function(_StartOfGame value)? startOfGame,
  }) {
    return connectedToExistingGame?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SearchingForExistingGame value)? searchingForExistingGame,
    TResult Function(_ConnectingToExistingGame value)? connectingToExistingGame,
    TResult Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult Function(_StartingServer value)? startingServer,
    TResult Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult Function(_StartOfGame value)? startOfGame,
    required TResult orElse(),
  }) {
    if (connectedToExistingGame != null) {
      return connectedToExistingGame(this);
    }
    return orElse();
  }
}

abstract class _ConnectedToExistingGame implements GameJoiningState {
  factory _ConnectedToExistingGame(final String serverIp) =
      _$_ConnectedToExistingGame;

  String get serverIp;
  @JsonKey(ignore: true)
  _$$_ConnectedToExistingGameCopyWith<_$_ConnectedToExistingGame>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_StartingServerCopyWith<$Res> {
  factory _$$_StartingServerCopyWith(
          _$_StartingServer value, $Res Function(_$_StartingServer) then) =
      __$$_StartingServerCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StartingServerCopyWithImpl<$Res>
    extends _$GameJoiningStateCopyWithImpl<$Res, _$_StartingServer>
    implements _$$_StartingServerCopyWith<$Res> {
  __$$_StartingServerCopyWithImpl(
      _$_StartingServer _value, $Res Function(_$_StartingServer) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_StartingServer implements _StartingServer {
  const _$_StartingServer();

  @override
  String toString() {
    return 'GameJoiningState.startingServer()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_StartingServer);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() searchingForExistingGame,
    required TResult Function() connectingToExistingGame,
    required TResult Function(String serverIp) connectedToExistingGame,
    required TResult Function() startingServer,
    required TResult Function(int numberOfPlayers) waitingForPlayers,
    required TResult Function(int numberOfPlayers) startOfGame,
  }) {
    return startingServer();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? searchingForExistingGame,
    TResult? Function()? connectingToExistingGame,
    TResult? Function(String serverIp)? connectedToExistingGame,
    TResult? Function()? startingServer,
    TResult? Function(int numberOfPlayers)? waitingForPlayers,
    TResult? Function(int numberOfPlayers)? startOfGame,
  }) {
    return startingServer?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? searchingForExistingGame,
    TResult Function()? connectingToExistingGame,
    TResult Function(String serverIp)? connectedToExistingGame,
    TResult Function()? startingServer,
    TResult Function(int numberOfPlayers)? waitingForPlayers,
    TResult Function(int numberOfPlayers)? startOfGame,
    required TResult orElse(),
  }) {
    if (startingServer != null) {
      return startingServer();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SearchingForExistingGame value)
        searchingForExistingGame,
    required TResult Function(_ConnectingToExistingGame value)
        connectingToExistingGame,
    required TResult Function(_ConnectedToExistingGame value)
        connectedToExistingGame,
    required TResult Function(_StartingServer value) startingServer,
    required TResult Function(_WaitingForPlayers value) waitingForPlayers,
    required TResult Function(_StartOfGame value) startOfGame,
  }) {
    return startingServer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SearchingForExistingGame value)?
        searchingForExistingGame,
    TResult? Function(_ConnectingToExistingGame value)?
        connectingToExistingGame,
    TResult? Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult? Function(_StartingServer value)? startingServer,
    TResult? Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult? Function(_StartOfGame value)? startOfGame,
  }) {
    return startingServer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SearchingForExistingGame value)? searchingForExistingGame,
    TResult Function(_ConnectingToExistingGame value)? connectingToExistingGame,
    TResult Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult Function(_StartingServer value)? startingServer,
    TResult Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult Function(_StartOfGame value)? startOfGame,
    required TResult orElse(),
  }) {
    if (startingServer != null) {
      return startingServer(this);
    }
    return orElse();
  }
}

abstract class _StartingServer implements GameJoiningState {
  const factory _StartingServer() = _$_StartingServer;
}

/// @nodoc
abstract class _$$_WaitingForPlayersCopyWith<$Res> {
  factory _$$_WaitingForPlayersCopyWith(_$_WaitingForPlayers value,
          $Res Function(_$_WaitingForPlayers) then) =
      __$$_WaitingForPlayersCopyWithImpl<$Res>;
  @useResult
  $Res call({int numberOfPlayers});
}

/// @nodoc
class __$$_WaitingForPlayersCopyWithImpl<$Res>
    extends _$GameJoiningStateCopyWithImpl<$Res, _$_WaitingForPlayers>
    implements _$$_WaitingForPlayersCopyWith<$Res> {
  __$$_WaitingForPlayersCopyWithImpl(
      _$_WaitingForPlayers _value, $Res Function(_$_WaitingForPlayers) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numberOfPlayers = null,
  }) {
    return _then(_$_WaitingForPlayers(
      null == numberOfPlayers
          ? _value.numberOfPlayers
          : numberOfPlayers // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_WaitingForPlayers implements _WaitingForPlayers {
  const _$_WaitingForPlayers(this.numberOfPlayers);

  @override
  final int numberOfPlayers;

  @override
  String toString() {
    return 'GameJoiningState.waitingForPlayers(numberOfPlayers: $numberOfPlayers)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WaitingForPlayers &&
            (identical(other.numberOfPlayers, numberOfPlayers) ||
                other.numberOfPlayers == numberOfPlayers));
  }

  @override
  int get hashCode => Object.hash(runtimeType, numberOfPlayers);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WaitingForPlayersCopyWith<_$_WaitingForPlayers> get copyWith =>
      __$$_WaitingForPlayersCopyWithImpl<_$_WaitingForPlayers>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() searchingForExistingGame,
    required TResult Function() connectingToExistingGame,
    required TResult Function(String serverIp) connectedToExistingGame,
    required TResult Function() startingServer,
    required TResult Function(int numberOfPlayers) waitingForPlayers,
    required TResult Function(int numberOfPlayers) startOfGame,
  }) {
    return waitingForPlayers(numberOfPlayers);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? searchingForExistingGame,
    TResult? Function()? connectingToExistingGame,
    TResult? Function(String serverIp)? connectedToExistingGame,
    TResult? Function()? startingServer,
    TResult? Function(int numberOfPlayers)? waitingForPlayers,
    TResult? Function(int numberOfPlayers)? startOfGame,
  }) {
    return waitingForPlayers?.call(numberOfPlayers);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? searchingForExistingGame,
    TResult Function()? connectingToExistingGame,
    TResult Function(String serverIp)? connectedToExistingGame,
    TResult Function()? startingServer,
    TResult Function(int numberOfPlayers)? waitingForPlayers,
    TResult Function(int numberOfPlayers)? startOfGame,
    required TResult orElse(),
  }) {
    if (waitingForPlayers != null) {
      return waitingForPlayers(numberOfPlayers);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SearchingForExistingGame value)
        searchingForExistingGame,
    required TResult Function(_ConnectingToExistingGame value)
        connectingToExistingGame,
    required TResult Function(_ConnectedToExistingGame value)
        connectedToExistingGame,
    required TResult Function(_StartingServer value) startingServer,
    required TResult Function(_WaitingForPlayers value) waitingForPlayers,
    required TResult Function(_StartOfGame value) startOfGame,
  }) {
    return waitingForPlayers(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SearchingForExistingGame value)?
        searchingForExistingGame,
    TResult? Function(_ConnectingToExistingGame value)?
        connectingToExistingGame,
    TResult? Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult? Function(_StartingServer value)? startingServer,
    TResult? Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult? Function(_StartOfGame value)? startOfGame,
  }) {
    return waitingForPlayers?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SearchingForExistingGame value)? searchingForExistingGame,
    TResult Function(_ConnectingToExistingGame value)? connectingToExistingGame,
    TResult Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult Function(_StartingServer value)? startingServer,
    TResult Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult Function(_StartOfGame value)? startOfGame,
    required TResult orElse(),
  }) {
    if (waitingForPlayers != null) {
      return waitingForPlayers(this);
    }
    return orElse();
  }
}

abstract class _WaitingForPlayers implements GameJoiningState {
  const factory _WaitingForPlayers(final int numberOfPlayers) =
      _$_WaitingForPlayers;

  int get numberOfPlayers;
  @JsonKey(ignore: true)
  _$$_WaitingForPlayersCopyWith<_$_WaitingForPlayers> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_StartOfGameCopyWith<$Res> {
  factory _$$_StartOfGameCopyWith(
          _$_StartOfGame value, $Res Function(_$_StartOfGame) then) =
      __$$_StartOfGameCopyWithImpl<$Res>;
  @useResult
  $Res call({int numberOfPlayers});
}

/// @nodoc
class __$$_StartOfGameCopyWithImpl<$Res>
    extends _$GameJoiningStateCopyWithImpl<$Res, _$_StartOfGame>
    implements _$$_StartOfGameCopyWith<$Res> {
  __$$_StartOfGameCopyWithImpl(
      _$_StartOfGame _value, $Res Function(_$_StartOfGame) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? numberOfPlayers = null,
  }) {
    return _then(_$_StartOfGame(
      null == numberOfPlayers
          ? _value.numberOfPlayers
          : numberOfPlayers // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_StartOfGame implements _StartOfGame {
  const _$_StartOfGame(this.numberOfPlayers);

  @override
  final int numberOfPlayers;

  @override
  String toString() {
    return 'GameJoiningState.startOfGame(numberOfPlayers: $numberOfPlayers)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StartOfGame &&
            (identical(other.numberOfPlayers, numberOfPlayers) ||
                other.numberOfPlayers == numberOfPlayers));
  }

  @override
  int get hashCode => Object.hash(runtimeType, numberOfPlayers);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StartOfGameCopyWith<_$_StartOfGame> get copyWith =>
      __$$_StartOfGameCopyWithImpl<_$_StartOfGame>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() searchingForExistingGame,
    required TResult Function() connectingToExistingGame,
    required TResult Function(String serverIp) connectedToExistingGame,
    required TResult Function() startingServer,
    required TResult Function(int numberOfPlayers) waitingForPlayers,
    required TResult Function(int numberOfPlayers) startOfGame,
  }) {
    return startOfGame(numberOfPlayers);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? searchingForExistingGame,
    TResult? Function()? connectingToExistingGame,
    TResult? Function(String serverIp)? connectedToExistingGame,
    TResult? Function()? startingServer,
    TResult? Function(int numberOfPlayers)? waitingForPlayers,
    TResult? Function(int numberOfPlayers)? startOfGame,
  }) {
    return startOfGame?.call(numberOfPlayers);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? searchingForExistingGame,
    TResult Function()? connectingToExistingGame,
    TResult Function(String serverIp)? connectedToExistingGame,
    TResult Function()? startingServer,
    TResult Function(int numberOfPlayers)? waitingForPlayers,
    TResult Function(int numberOfPlayers)? startOfGame,
    required TResult orElse(),
  }) {
    if (startOfGame != null) {
      return startOfGame(numberOfPlayers);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_SearchingForExistingGame value)
        searchingForExistingGame,
    required TResult Function(_ConnectingToExistingGame value)
        connectingToExistingGame,
    required TResult Function(_ConnectedToExistingGame value)
        connectedToExistingGame,
    required TResult Function(_StartingServer value) startingServer,
    required TResult Function(_WaitingForPlayers value) waitingForPlayers,
    required TResult Function(_StartOfGame value) startOfGame,
  }) {
    return startOfGame(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_SearchingForExistingGame value)?
        searchingForExistingGame,
    TResult? Function(_ConnectingToExistingGame value)?
        connectingToExistingGame,
    TResult? Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult? Function(_StartingServer value)? startingServer,
    TResult? Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult? Function(_StartOfGame value)? startOfGame,
  }) {
    return startOfGame?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_SearchingForExistingGame value)? searchingForExistingGame,
    TResult Function(_ConnectingToExistingGame value)? connectingToExistingGame,
    TResult Function(_ConnectedToExistingGame value)? connectedToExistingGame,
    TResult Function(_StartingServer value)? startingServer,
    TResult Function(_WaitingForPlayers value)? waitingForPlayers,
    TResult Function(_StartOfGame value)? startOfGame,
    required TResult orElse(),
  }) {
    if (startOfGame != null) {
      return startOfGame(this);
    }
    return orElse();
  }
}

abstract class _StartOfGame implements GameJoiningState {
  const factory _StartOfGame(final int numberOfPlayers) = _$_StartOfGame;

  int get numberOfPlayers;
  @JsonKey(ignore: true)
  _$$_StartOfGameCopyWith<_$_StartOfGame> get copyWith =>
      throw _privateConstructorUsedError;
}
